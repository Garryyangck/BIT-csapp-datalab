## 一、实验目的

本实验目的是加强学生对位级运算的理解及熟练使用的能力。

## 二、报告要求

本报告要求学生把实验中实现的所有函数逐一进行分析说明，写出实现的依据，也就是推理过程，可以是一个简单的数学证明，也可以是代码分析，根据实现中你的想法不同而异。

## 三、函数分析

1. bitXor函数

**函数要求：**

函数名 | bitXor
-|-
参数 | int , int
功能实现 | x^y
要求 | 只能使用 ~ 和 & 

**实现分析：**

由德摩根律: (x & ~y) | (y & ~x) = ~(~(x & ~y) & ~(y & ~x))。

**函数实现：**

```C
int bitXor(int x, int y) {
  return ~(~(x & ~y) & ~(y & ~x));
}
```



2. getByte函数

**函数要求：**

| 函数名   | getByte                    |
| -------- | -------------------------- |
| 参数     | int , int                  |
| 功能实现 | 在word x中提取第n个字节    |
| 要求     | 只能使用! ~ & ^ \| + << >> |

**实现分析：**

x 算术右移 (n \* 8) = (n << 3) 个位后，与掩码 0xff 按位与运算。

**函数实现：**

```C
int getByte(int x, int n) {
  return (x >> (n << 3)) & 0xff;
}
```



3. logicalShift函数

**函数要求：**

| 函数名   | logicalShift               |
| -------- | -------------------------- |
| 参数     | int , int                  |
| 功能实现 | 将x向右移n位               |
| 要求     | 只能使用! ~ & ^ \| + << >> |

**实现分析：**

关键在于 x 为负数时，算术右移会使用 1 而不是 0 填补高位，因此需要高位一连串 0 作为掩码；

得到掩码的方式为取最高位，将其算术右移 n 位后再左移 1 位，得到的结果取反，即符号位为 1，最后可以得到 00..011..1 的掩码。

**函数实现：**

```C
int logicalShift(int x, int n) {
  int sign = (x & (0x1 << 31));
  int mask = ~((sign >> n) << 1);
  return (x >> n) & mask;
}
```



4. bitCount函数

**函数要求：**

| 函数名   | bitCount                   |
| -------- | -------------------------- |
| 参数     | int                        |
| 功能实现 | 计算输入字节中为1的bit数   |
| 要求     | 只能使用! ~ & ^ \| + << >> |

**实现分析：**

1. x & 0x55555555 只留下奇数位的 1；
2. (x >> 1) & 0x55555555 只留下偶数位的 1, 并且因为向右移 1 位, 导致和奇数位留下的 1 对齐；
3. 这样 1、2 中的结果相加后将结果赋给 x，x 的每两位的值代表原 x 中那对应两位上 1 的个数之和。
4. 同理，x & 0x33333333 与 (x >> 2) & 0x33333333 的结果相加后赋给 x，x 的每四位的值代表原 x 中那对应四位上 1 的个数之和。
5. 以此类推，直到 x 的值为原 x 中对应那三十二位中 1 的个数和，即bitCount。

**函数实现：**

```C
int bitCount(int x) {
  int _mask1 = 0x55 | (0x55 << 8);
  int mask1 = _mask1 | (_mask1 << 16);
  int _mask2 = 0x33 | (0x33 << 8);
  int mask2 = _mask2 | (_mask2 << 16);
  int _mask3 = 0x0f | (0x0f << 8);
  int mask3 = _mask3 | (_mask3 << 16);
  int mask4 = 0xff | (0xff << 16);
  int mask5 = 0xff | (0xff << 8);
  x = (x & mask1) + ((x >> 1) & mask1);
  x = (x & mask2) + ((x >> 2) & mask2);
  x = (x & mask3) + ((x >> 4) & mask3);
  x = (x & mask4) + ((x >> 8) & mask4);
  x = (x & mask5) + ((x >> 16) & mask5);
  return x;
}
```



5. conditional函数

**函数要求：**

| 函数名   | conditional                |
| -------- | -------------------------- |
| 参数     | int , int , int            |
| 功能实现 | 实现x ? y : z              |
| 要求     | 只能使用! ~ & ^ \| + << >> |

**实现分析：**

分析：

真, 选 y, x != 0, !x = 0x0

假, 选 z, x == 0, !x = 0x1

于是构造掩码 !!x << 31 >> 31，真的时候为 0xffffffff；假的时候为 0x00000000。

y & mask，那么真的时候选 y；z & ~mask，假的时候选 z。

**函数实现：**

```C
int conditional(int x, int y, int z) {
  int mask = !!x << 31 >> 31;
  return (y & mask) | (z & ~mask);
}
```



6. tmin函数

**函数要求：**

| 函数名   | tmin                       |
| -------- | -------------------------- |
| 参数     | void                       |
| 功能实现 | 返回最小补码               |
| 要求     | 只能使用! ~ & ^ \| + << >> |

**实现分析：**

最小的 int 数: -2147483648 = 0x800000000。

**函数实现：**

```C
int tmin(void) {
  return (0x1) << 31;
}
```



7. fitsBits函数

**函数要求：**

| 函数名   | fitsBits                            |
| -------- | ----------------------------------- |
| 参数     | int , int                           |
| 功能实现 | 若x能用n个bit表示则返回1，否则返回0 |
| 要求     | 只能使用! ~ & ^ \| + << >>          |

**实现分析：**

将 x 向左移 (32 - n) 位后再右移相同位数，如果可以用 n 位表示则与原来的 x 相同，否则不同。

**函数实现：**

```C
int fitsBits(int x, int n) {
  int b = 32 + ~n + 1;
  int t = x << b >> b;
  return !(x ^ t);
}
```



8. dividePower2函数

**函数要求：**

| 函数名   | dividePower2               |
| -------- | -------------------------- |
| 参数     | int , int                  |
| 功能实现 | 计算x/(2^n)，其中0<=n<=30  |
| 要求     | 只能使用! ~ & ^ \| + << >> |

**实现分析：**

题目要求是向零舍入, 也就是正数向下舍入, 负数向上舍入，需要加入一个偏移因子 bias = ((0x1 << n) + ~0) & (x >> 31) 后再右移，否则负数会向下舍入。

**函数实现：**

```C
int dividePower2(int x, int n) {
  int mask = (0x1 << n) + ~0;
  int sign = x >> 31;
  int bias = sign & mask;
  return (x + bias) >> n;
}
```



9. negate函数

**函数要求：**

| 函数名   | negate                     |
| -------- | -------------------------- |
| 参数     | int                        |
| 功能实现 | 取相反数                   |
| 要求     | 只能使用! ~ & ^ \| + << >> |

**实现分析：**

根据负数补码 = 绝对值的取反 + 1，得到 -x = ~x + 1。

**函数实现：**

```C
int negate(int x) {
  return ~x + 1;
}
```



10. howManyBits函数

**函数要求：**

| 函数名   | howManyBits                |
| -------- | -------------------------- |
| 参数     | int                        |
| 功能实现 | 返回表示x所要用的最小bit数 |
| 要求     | 只能使用! ~ & ^ \| + << >> |

**实现分析：**

分析：

x 先异或相邻的数，可以把前面的一长串 0 或 1 全部变为 0。

举例：

1. 如 (12)0..01010，经过异或后变为 0..011110，最高位为 4，加上符号位为 5，即为答案。
2. 如 (-5)1..1011，经过异或后变为 0..01100，最高位为 3，加上符号位为 4，即为答案。

可以 int y = x ^ (x << 1)，之后寻找 y 的最高位，可以使用 12.intLog2 函数得到，最后结果再加上符号位的 1 位即可。

**函数实现：**

```C
int howManyBits(int x) {
  int y = x ^ (x << 1);
  int mask = ~0;
  int count = 0;
  count += (!!(y & (mask << 16))) << 4;
  count += (!!(y & (mask << (count + 8)))) << 3;
  count += (!!(y & (mask << (count + 4)))) << 2;
  count += (!!(y & (mask << (count + 2)))) << 1;
  count += (!!(y & (mask << (count + 1))));
  return count + 1;
}
```



11. isLessOrEqual函数

**函数要求：**

| 函数名   | isLessOrEqual              |
| -------- | -------------------------- |
| 参数     | int , int                  |
| 功能实现 | 若x<=y则返回1，否则返回0   |
| 要求     | 只能使用! ~ & ^ \| + << >> |

**实现分析：**

这道题看完第一眼觉得应该直接减法得到结果后判断正负，但是还需要考虑溢出的情况（我最开始就是没考虑溢出，直接减最后报错）：当 x 和 y 同号时，二者相减不会发生溢出；当 x 和 y 异号时，二者相减可能会发生溢出，但是既然他俩都异号了，可以直接用正负性判断得出结果。

x <= y => x < y + 1 => x - y - 1 = x + ~y < 0，int val = !!((x + ~y) >> 31)，val = 1 时为真。

**函数实现：**

```C
int isLessOrEqual(int x, int y) {
  int val = !!((x + ~y) >> 31);
  x = x >> 31;
  y = y >> 31;
  return (!!x & !y) | (~(!x & !!y) & val);
}
```



12. intLog2函数

**函数要求：**

| 函数名   | intLog2                    |
| -------- | -------------------------- |
| 参数     | int                        |
| 功能实现 | 计算log2(x)并向下取整      |
| 要求     | 只能使用! ~ & ^ \| + << >> |

**实现分析：**

这个问题的实质是找最高位的 1 在哪一位。

总体思路: 将判断 x 是否有数的区间大小, 从 16 -> 8 -> 4 -> 2 -> 1, 最终得到精确的位

1. 构造掩码 mask = ~0，计数器 count 初值为 0；
2. 判断 x 16~31 位是否有数, 有则使用 !! 将其变为 1, 并且 1<<4=16, 为 count 赋初值 16：
3. 若此时 count = 16, 说明最高位 >= 16, 因此需要进一步向上试探，再使用“折半法”, 试探前四分之一, 即 24~31 是否有数, 有则 count+8=24, 意为 x 的最高位 >= 24；
4. 若此时 count = 0, 说明 x 的前 16 位均为 0, 因此试探第 8~15 位是否有数，有则 count+8=8, 说明 x 的最高位在 8~15 位；
5. 1以此类推, 直到最小区间变为 1, 即只需判断最后一位是否为 1。

**函数实现：**

```C
int intLog2(int x) {
  int mask = ~0;
  int count = 0;
  count += (!!(x & (mask << 16))) << 4;
  count += (!!(x & (mask << (count + 8)))) << 3;
  count += (!!(x & (mask << (count + 4)))) << 2;
  count += (!!(x & (mask << (count + 2)))) << 1;
  count += (!!(x & (mask << (count + 1))));
  return count;
}
```



13. floatAbsVal函数

**函数要求：**

| 函数名   | floatAbsVal                         |
| -------- | ----------------------------------- |
| 参数     | unsigned                            |
| 功能实现 | 返回浮点数f的绝对值                 |
| 要求     | 可以使用运算符, \|\|, &&, if, while |

**实现分析：**

1. 需要考虑特殊情况：NaN，直接返回自身，判断 NaN 的依据是指数部分全为 1，且小数部分不全为 0。
1. 不是 NaN 则直接改变符号位为 0。

**函数实现：**

```C
unsigned floatAbsVal(unsigned uf) {
  if (!((uf & 0x7f800000) ^ 0x7f800000) && (uf & 0x007fffff))
    return uf;
  return uf & 0x7fffffff;
}
```



14. floatScale1d2函数

**函数要求：**

| 函数名   | floatScale1d2                       |
| -------- | ----------------------------------- |
| 参数     | unsigned                            |
| 功能实现 | 返回0.5*f                           |
| 要求     | 可以使用运算符, \|\|, &&, if, while |

**实现分析：**

1. 如果为 INF(指数为 0xff 且小数部分为 0) 或 NaN(指数为 0xff 且小数部分 > 0)，直接返回原值；
1. 若 exp > 1，直接 exp - 1；
1. 若此时指数位为 0 或 1，由于小数部分移位后需要向上取整，因此最低位若为 011，则移位后应变为 010 而不是 001，进行特殊处理：011 + 010 = 101，101 经过 >> 1 后变为 010，成功向上取整；
1. 特殊处理后，若 exp = 0，则直接右移经过特殊处理后的小数部分；若 exp = 1，则把指数位最低位的 1，移动到小数部分的最高位；因此操作为 uf >> 1，但是要避免符号位为 1 时影响指数位最高位，因此结果要 & 0x3fffffff，使指数位最高位为 0。

**函数实现：**

```C
unsigned floatScale1d2(unsigned uf) {
  unsigned sign = uf & 0x80000000;
  unsigned exp = (uf >> 23) & 0xff;
  if (exp == 0xff) {
    return uf;
  }
  if (exp > 1)
    return (uf & 0x807fffff) | (--exp) << 23;
  if ((uf & 0x3) == 0x3)
    uf = uf + 0x2;
  return ((uf >> 1) & 0x3fffffff) | sign;
}
```



15. floatFloat2Int函数

**函数要求：**

| 函数名   | floatFloat2Int                      |
| -------- | ----------------------------------- |
| 参数     | unsigned                            |
| 功能实现 | 将f转换为int形式                    |
| 要求     | 可以使用运算符, \|\|, &&, if, while |

**实现分析：**

1. 先对输入进行处理得到 sign、exp 和 frac；
2. 若 exp >= 32，超过 int 的上限，返回 0x80000000；
3. 若 exp < 0 或 uf == 0, 返回 0；
4. 根据 exp 大小，将小数部分移动合适的位数，变为整数，exp > 23 则左移使 frac 继续变大；
6. 若为正数，则直接返回 frac；负数则返回补码，负数的补码等于绝对值取反 + 1。

**函数实现：**

```C
int floatFloat2Int(unsigned uf) {
  int sign = uf >> 31;
  int exp = ((uf & 0x7f800000) >> 23) - 127;
  int frac = (uf & 0x007fffff) | 0x00800000;
  if (exp > 31)
    return 0x80000000;
  if (exp < 0 | !(exp | frac))
    return 0;
  if (exp > 23)
    frac <<= (exp - 23);
  else
    frac >>= (23 - exp);
  if (!(sign ^ 0x0))
    return frac;
  else
    return ~frac + 1;
}
```



## 四、实验总结

**实验收获**：

我对位级操作有了更深刻的理解，这不仅包括了基本的位运算符使用，还涉及到了如何巧妙地使用这些操作来实现复杂的逻辑和算术功能。其次，我的编程技能得到了显著提升，尤其是在C语言的底层编程方面，我学会了如何更加高效和精确地编写代码。

在实现`logicalShift`函数时，我需要考虑如何处理负数的逻辑右移，这要求我对二进制表示和移位操作有深入的理解。此外，通过实现如`floatAbsVal`和`floatFloat2Int`等函数，我对浮点数的IEEE 754表示有了更直观的认识，了解了如何从二进制层面理解和操作浮点数，这是对计算机内部如何表示和处理数据的重要洞察。我也深刻体会到了细节的重要性，尤其是在实现`bitCount`函数时，即使是微小的错误，也可能导致整个程序的行为不正确。实验中的挑战也提高了我的调试技能，我学会了如何使用各种工具和方法来测试我的代码，确保它在各种情况下都能正确运行。在遇到不熟悉的概念或问题时，我学会了如何独立研究和学习，这种自我驱动的学习方式对我的个人成长至关重要。

**实验建议**：

实验文档表述不是很清楚。

难度较大，建议增加一些提示。

实验的虚拟机好卡，而且必须全屏才能操作很不方便。



